
## 8.1 디스크 읽기 방식

데이터베이스 성능 튜닝의 핵심은 **디스크 I/O를 얼마나 줄이느냐에 따라 결정된다.**

### 8.1.1 HDD vs SSD

- **병목 지점**: 데이터 서버에서는 항상 디스크 장치가 병목이 됨
- **HDD**: 기계식 저장 장치, 플래터(원판)를 회전시켜 데이터 읽기/쓰기
- **SSD**: 전자식 저장 매체, 플래시 메모리 사용
    - 기계적 회전이 없어 훨씬 빠른 속도 제공

### 8.1.2 랜덤 I/O vs 순차 I/O

### 차이점

- **순차 I/O**: 3개 페이지 → 1번 시스템 콜 → 디스크 헤더 1번 이동
- **랜덤 I/O**: 3개 페이지 → 3번 시스템 콜 → 디스크 헤더 3번 이동

### 성능 차이

디스크 성능은 **헤더 이동 횟수**에 의해 결정됩니다.

- 위 예시에서 순차 I/O가 랜덤 I/O보다 약 **3배 빠름**

### 쿼리 튜닝의 목표

> ⚠️ 랜덤 I/O를 순차 I/O로 바꾸는 것은 거의 불가능
>

**실제 목표**: 랜덤 I/O 자체를 줄이기

- 꼭 필요한 데이터만 읽도록 쿼리 개선
- 불필요한 데이터 접근 최소화

> 💡 인덱스의 역할
>
>
> 인덱스는 랜덤 I/O를 순차 I/O로 바꾸는 것이 아니라,
>
> **랜덤 I/O의 횟수 자체를 줄여서** 성능을 향상시킨다.
>

---

## 8.2 인덱스란?

### 기본 개념

인덱스는 책의 **찾아보기**와 같다.

- 칼럼의 값을 미리 정렬해서 보관
- `SortedList` 자료구조와 유사

### 성능 트레이드오프

| 작업 | 성능 |
| --- | --- |
| SELECT | ⚡ 매우 빠름 (이미 정렬됨) |
| INSERT/UPDATE/DELETE | 🐢 느림 (정렬 유지 필요) |

> 핵심: 인덱스는 데이터 저장 성능을 희생하고 읽기 성능을 향상시키는 기능
>

### 인덱스 추가 결정 기준

- 저장 속도를 어디까지 희생할 수 있는가?
- 읽기 속도를 얼마나 빠르게 만들어야 하는가?

---

## 8.3 인덱스 분류

### 역할별 구분

- **프라이머리 키 (Primary Key)**: 주 키
- **세컨더리 인덱스 (Secondary Index)**: 프라이머리 키를 제외한 모든 인덱스

### 알고리즘별 구분

### B-Tree 인덱스

- 가장 일반적인 인덱스 구조
- 범위 검색, 정렬에 유리

### Hash 인덱스

**장점**

- 매우 빠른 검색 (해시 값 기반)

**단점**

- 전방 일치 검색 불가 (예: `LIKE 'abc%'`)
- 범위 검색 불가
- 정렬 불가

**사용처**

- Redis 같은 메모리 기반 데이터베이스에서 주로 사용한다.