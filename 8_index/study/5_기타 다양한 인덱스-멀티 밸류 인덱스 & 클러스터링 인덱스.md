## 멀티 밸류 인덱스

멀티 밸류 인덱스란, 일반적으로 데이터 레코드 한 건이 하나의 인덱스를 가지는 것과 달리, JSON 배열 형태의 경우 배열 요소 하나하나마다 인덱스를 가질 수 있는 것을 의미한다.

예를 들어 다음을 보자.

```json
{
  "name": "김철수",
  "tags": ["개발자", "백엔드", "MySQL"]
}
```

기존에는 tags 배열 안에 특정 값을 찾으려면, 멀티 인덱스를 지원하지 않아 전체 테이블 스캔을 했어야 했다

그러나 MySQL 8.0 이상 부터 멀티 밸류 인덱스가 추가 되면서 **JSON 배열의 각 요소마다 인덱스 엔트리를 생성**할 수 있게된 것이다.

```sql
CREATE TABLE users (
    id INT PRIMARY KEY,
    profile JSON,
    INDEX idx_tags ((CAST(profile->'$.tags' AS CHAR(50) ARRAY)))
);
```

멀티 밸류 인덱스를 활용하기 위해서는 일반적인 조건 방식을 사용하면 안되고, 반드시 다음 함수들을 이용해서 검색해야 옵티마이저가 인덱스를 활용한 실행 계획을 수립한다.

- MEMBER OF()
- JSON_CONTAINS()
- JSON_OVERLAPS()

---

## 클러스터링 인덱스

클러스터링 이라는 것은 여러개를 하나로 묶는다는 의미를 가진다.

MySQL 서버에서 클러스터링은 테이블의 레코드를 비슷한 것(프라이머리 키를 기준으로)들끼리 묶어서 저장하는 형태로 구현되는데, 이는 주로 비슷한 것들을 동시에 조회하는 경우가 많다는 것에서 착안한 것이다.

### 클러스터링 인덱스

PK의 값이 비슷한 레코드 끼리 묶어서 저장하는 것을 클러스터링 인덱스라고 하는데, 그렇기 때문에 사실상 인덱스 알고리즘이라기 보다는 테이블 레코드의 저장 방식에 가깝다.

왜냐하면 프라이머키 키 값에 의해 레코드의 저장 위치가 결정되기 때문!!!

MySQL에서 인덱스는 프라이머리 인덱스로 일컫어지는 PK에 자동으로 생성되는 인덱스와, 우리가 직접 지정하는 세컨더리 인덱스 두 가지가 존재한다.

클러스터링 인덱스는  프라이머리 인덱스에 적용되는 개념으로, InnoDB의 경우 세컨더리 인덱스로 PK를 찾고, 그 안에서 클러스터링 인덱스를 통해 테이블 레코드를 찾는 형식이다. 즉, 세컨더리 인덱스에 직접 데이터의 위치 주소가 저장되어 있는 MyISAM과는 방식이 다르다.

### 만약, PK가 없다면 클러스터링 인덱스는 어떻게 구성될까?

앞에서 pk를 기준으로 클러스터링 인덱스를 구성한다고 말한 바가 있다

그렇다면 만약, PK가 없는 InnoDB 테이블은 어떻게 클러스터링 테이블로 구성될까?

PK가 없는 경우 다음의 우선순위대로 InnoDB 스토리지 엔진이 PK를 대체할 칼럼을 선택한다

> 1. 프라이머리 키가 있으면 기본적으로 프라이머리 키를 클러스터링 키로 선택
> 2. NOT NULL 옵션의 유니크 인덱스 중에서 첫 번째 인덱스를 클러스터링 키로 선택
> 3. 자동으로 유니크한 값을 가지도록 증가되는 컬럼을 내부적으로 추가한 후, 클러스터링 키로 선택

3번의 경우 내부적으로 InnoDB 스토리지 엔진이 일련번호 컬럼을 생성하므로, 자동으로 생성되어 사용자에게 노출되지 않는다.
뒤에서 얘기 하겠지만, 이러한 이유로 명시적으로 반드시 PK를 두는 것이 좋다.

### 클러스터링 테이블 사용시 주의 사항

#### 1. 클러스터링 인덱스 키의 크기

클러스터링 테이블의 경우, 모든 세컨더리 인덱스가 프라이머리 키(클러스터링 키) 값을 포함한다.
그래서 프라이머리 키의 크기가 커지면, 인덱스도 자동으로 커지기 때문에 InnoDB 테이블의 프라이머리 키는 신중하게 선택해야 한다.

#### 2. 프라이머리 키는 AUTO-INCREMENT 보다는 업무적인 칼럼으로 명시할 것

InnoDB의 프라이머리 키는 클러스터링 키로 사용되며, **이 값이 무엇이느냐**가 엄청난 차이를 만들어 낸다.

그러므로, 설령 그 칼럼의 크기가 크더라도 업무적으로 해당 레코드를 대표할 수 있다면 그 칼럼을 프라이머리 키로 선택하는 것이 좋다.

#### 3. 프라이머리 키는 반드시 명시할 것

가능하면 AUTO-INCREMENT를 사용해서라도 PK는 명시하는 것이 좋다.

왜냐하면 위에서도 말했듯이, PK가 없을 경우 내부 엔진이 자동으로 생성하는데 이는 사용자가 사용할 수 없다.

#### 4. AUTO-INCREMENT 칼럼을 인조 식별자로 사용할 경우

PK가 길더라도 세컨더리 인덱스가 필요하지 않다면 그대로 프라이머리키를 사용하는 것이 좋다. 

왜냐하면 세컨더리 인덱스가 PK를 항상 포함하기 때문에 크기를 조심해야 하는건데 그 걱정 할 필요가 없는거라..

그러나 세컨더리 인덱스도 필요하고, PK의 크기도 같다면 AUTO-INCREMENT칼럼을 추가하고, 이를 PK로 설정하면 된다.