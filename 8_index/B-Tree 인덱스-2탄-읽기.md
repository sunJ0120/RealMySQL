## B-Tree 인덱스를 통한 데이터 읽기

결국, 어떤 경우에 인덱스를 사용하게 유도할지, 또는 사용하지 못하게 할지 판단하려면 MySQL이 어떻게 인덱스를 이용(경유)해서 실제 레코드를 읽어 내는지 알아야 한다. 그러므로 이제는 인덱스를 어떻게 **"읽는지"** 에 대한 방식을 알아보자.

### 1. 인덱스 레인지 스캔

검색해야 할 인덱스의 범위가 결정되었을 때 사용하는 방식을 말한다.

#### 동작 방식

B-Tree 자체가 루트와 브랜치 노드는 탐색을 위해 가야 할 위치 방향성만 알려주고, 리프 노드에 데이터 레코드 정보(주소)가 들어 있기 때문에, 최종적으로 리프 노드까지 찾아 들어가야만 비로소 필요한 레코드의 시작 지점을 찾을 수 있다.

리프 노드는 전부 Linked List로 연결되어 있기 때문에, 일단 시작해야 할 위치를 찾으면 그때부터는 리프 노드의 레코드만 순서대로 읽어주면 된다.

여기서 스캔을 진행하다가 리프 노드의 끝까지 읽었다면, 리프 노드 간의 링크를 이용해 다음 리프 노드를 찾아서 다시 스캔을 진행하는 것이다.

#### 자동 정렬

인덱스 자체가 정렬되어 있기 때문에 인덱스를 통해 가져오는 값은 별도의 정렬이 필요 없다. 그래서 따로 ORDER BY 등을 할 필요도 없는 것이다.

#### 랜덤 I/O 발생

여기서 또 중요한 개념 중 하나는, 인덱스의 리프 노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어 오는 과정이 추가로 필요하다는 것이다.

예를 들어, 3건의 레코드가 검색 조건에 일치했다면 3건의 **랜덤 I/O**가 발생한다. 이 작업 자체가 품이 많이 들기 때문에 인덱스를 통해 읽어야 할 레코드가 **20~25%를 넘어가면 인덱스를 통한 읽기보다 테이블의 데이터를 직접 읽는 것이 더 효율적인 처리 방식이 된다**고 앞에서 언급한 것이다!

### 2. 인덱스 풀 스캔

인덱스의 처음부터 끝까지 모두 읽는 방식이다.

인덱스 자체가 테이블보다 무조건 크기가 작기 때문에 인덱스 풀 스캔을 진행하더라도 테이블 풀 스캔보다는 품이 덜 든다. (즉, 더 작은 디스크 I/O로 처리가 가능하다.)

그러나 이 방식은 어찌 되었든 인덱스를 이용해서 빠른 검색을 가능하게 한다는 일반적인 인덱스 사용 목적에 어긋난다.

### 3. 루스 인덱스 스캔

이 인덱스 스캔 방식은 말 그대로 느슨하게, 혹은 듬성듬성하게 인덱스를 읽는 것을 의미한다.

이 방식은 중간에 필요하지 않은 키는 스킵하고 넘어가는 형태를 띤다. 예를 들어, 다음과 같은 쿼리 질의가 있다고 하자.

```sql
SELECT dept_no, MIN(emp_no)
FROM dept_emp
WHERE dept_no BETWEEN 'd002' AND 'd004'
GROUP BY dept_no;
```

이런 쿼리가 있다면, 옵티마이저는 각 dept_no 그룹의 첫 번째 레코드(MIN 값)만 읽으면 되기 때문에, 각 그룹의 나머지 레코드들은 스킵하고 다음 그룹으로 넘어가게 된다.

### 4. 인덱스 스킵 스캔

MySQL 8.0부터 도입된 기능이다.

#### 기본 개념

일반적으로 인덱스를 사용하려면, WHERE 절에 인덱스의 선행 컬럼이 포함되어 있어야 한다. 그래야 인덱스를 사용할 수 있기 때문이다.

그러나 인덱스 스킵 스캔은, 옵티마이저가 인덱스의 선행 컬럼에 대한 조건을 자동으로 WHERE 절에 추가해주어 인덱스 레인지 스캔을 실행한다.

```sql
*- 인덱스: (gender, birth_date)- 쿼리*
SELECT * FROM users WHERE birth_date = '1990-01-01';
*- 옵티마이저가 내부적으로 변환*
SELECT * FROM users WHERE gender = 'M' AND birth_date = '1990-01-01'
UNION ALL
SELECT * FROM users WHERE gender = 'F' AND birth_date = '1990-01-01';
```

#### 제약 사항

1. **WHERE 조건절에 없는 인덱스의 선행 컬럼의 유니크한 값의 개수가 적어야 한다.**
    - 선행 컬럼의 유니크 값이 많으면 레인지 스캔을 여러 번 해야 하므로 비효율적이다.
2. **쿼리가 인덱스에 존재하는 컬럼만으로 처리 가능해야 한다. (커버링 인덱스)**
    - SELECT에서 인덱스에 존재하지 않는 컬럼을 필요로 하는 경우, 결국 데이터 레코드를 읽어야 하므로 랜덤 I/O가 발생한다.
    - 이 경우 인덱스 스킵 스캔의 이점이 줄어들 수 있다.