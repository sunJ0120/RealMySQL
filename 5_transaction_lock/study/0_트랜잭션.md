## 트랜잭션

트랜잭션 작업은 말하자면, 작업의 완전성을 보장해 주는 것이다.

즉, 논리적인 작업 셋을 모두 완벽하게 처리하거나, 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상(Patial update)이 발생하지 않도록 만들어 주는 것을 말한다.

잠금(Lock)과 트랜잭션은 서로 비슷해보이지만 사실 그 개념이 다르다.

**잠금은 동시성을 제어하기 위한 기능이고 트랜잭션은 데이터의 정합성을 보장**하기 위한 기능이다.

### MySQL에서의 트랜잭션

트랜잭션은 하나의 논리적인 작업셋에 하나의 쿼리가 있든, 두 개 이상의 쿼리가 있든 관계없이 논리적인 작업 셋 자체가 100% 적용되거나 (COMMIT을 실행했을때) 아무것도 적용되지 않아야(RollBack 또는 트랜잭션을 RollBack 시키는 오류가 발생했을 때)하는 것이다.

MySQL의 기본 엔진인 InnoDB는 기본적으로 트랜잭션이 적용되어 있지만, MyISAM 같은 경우는 이것이 적용되어 있지 않다.

트랜잭션이라 함은, 애플리케이션 개발에서 고민해야 할 문제를 줄여주는 필수적인 DBMS의 기능 중 하나이다. 왜냐하면 부분 업데이트 현상이 발생하면 실패한 쿼리로 남은 레코드를 다시 삭제하는 재처리 작업이 필요하기 때문이다.

하나의 쿼리일 경우에는 이 재처리 작업이 간단하지 않은가? 하는 생각이 들 수 있다. 그러나 쿼리가 두 개 이상으로 늘어나면 말이 달라진다.

쿼리가 2개 이상이 실행되는데 트랜잭션이 적용되지 않아 실패한 쿼리를 없애야 하는 경우 다음 예제와 같이 상당한 고민거리가 될 것 이다!

```sql
INSERT INTO tab_a ...;
IF(_is_insert1_suceed){
	INSERT INTO tab_b ...;
	IF(_is_insert2_suceed){
		//처리 완료 
	}ELSE{
		DELETE FROM tab_a WHERE ...;
		IF(_is_delete_suceed){
			//처리 실패, tab_a, tab_b 원상복구 로직 (트랜잭션이 없으니 수동으로 되돌려야 한다.)
		}ELSE{
			//해결 불가능
		}
	}
}
```

자 상당히 복잡하지 않은가? 이 코드를 트랜잭션이 지원되는 InnoDB 기반으로 변경하면 다음과 같이 간단하게 변경이 가능하다.

```sql
try{
	START TRANSACTION;
	INSERT INTO tab_a ...;
	INSERT INTO tab_b ...;
	COMMIT; //모아서 커밋
} catch(exception){
	ROLLBACK; //한 번에 롤백
}
```

### 주의사항!!!!

반드시 주의해야 할 것이 있다. 바로 트랜잭션 또한 DBMS의 커넥션과 동일하게 꼭 필요한 코드에만 적용하는 것이 좋다는 것이다.

즉, 프로그램 코드에서 트랜잭션의 범위를 최소화 하는 것이 좋다는 것이다.

자 이 최소화 예제를 실제 게시판에 글을 쓰는 과정을 통해 알아보도록 하자.

### 게시판에 글 쓰는 과정과 트랜잭션_잘못된 예제

```
1) 처리 시작
==> 데이터 베이스 커넥션 시작
==> 트랜잭션 시작
2) 사용자의 로그인 여부 확인
3) 사용자의 글쓰기 내용의 오류 여부 확인
4) 첨부로 업로드 된 파일 확인 및 저장
5) 사용자의 입력 내용을 DBMS에 저장
6) 첨부 파일 정보를 DBMS에 저장
7) 저장된 내용 또는 기타 정보를 DBMS에서 조회
8) 게시물 등록에 대한 알림 메일을 발송
9) 알람 메일 발송 이력을 DBMS에 저장
<== 트랜잭션 종료(COMMIT)
<== 데이터베이스 커넥션 반납
10) 처리 완료
```

자, 아무 생각 없이 봤을땐 아무 문제가 없어 보이는 코드이지만, 여기에는 치명적인 문제점들이 섞여 있다. 지금부터 이걸 분석하면서 **왜 트랜잭션을 작게 유지해야 하는지**를 알아보자.

#### 시작점의 문제

이 예제에서는 1) 부터 트랜잭션을 열었지만, 정작 DB 접근이 필요해서 트랜잭션을 시작해야 하는 부분은

**5) 사용자의 입력 내용을 DBMS에 저장** 부터이다. 즉, 2,3,4 절차가 아무리 빠르게 시작된다고 하더라도, 트랜잭션에 굳이 포함할 필요가 없다

일반적으로 데이터베이스 커넥션은 갯수가 제한적이라 각 단위 프로그램이 커넥션을 소유하는 시간이 길어질수록 사용 가능한 여유 커넥션이 줄어든다. 즉 불필요하게 자원이 낭비된다는 것이다.

#### 네트워크 작업의 문제

사실 가장 위험한 작업은 8) 작업이다. 메일 전송이나 FTP 파일 전송 작업 또는 네트워크를 통해 원격 서버와 통신하는 등과 같은 작업은 어떻게 해서든 DBMS의 트랜잭션 내에서 제거하는 것이 좋다.

네트워크 통신에 장애가 생길 경우, 연관된 DBMS 서버까지 위험해 질 수 있기 때문이다. 특히 이럴 경우 데드락이 걸리거나 타임아웃 위험이 있으므로 주의해야 한다.

#### 묶기의 문제

5), 6)의 경우 연관된 작업이라 묶어서 처리하는 것이 좋다. 그러나 9)는? 완전히 다른 작업이기 때문에 함께 묶지 않아도 무관하다. 또한 7) 은 간단 조회에 해당하는 내용이므로 별도로 트랜잭션을 사용해서 정합성을 보장할 필요가 없다.

> 자, 이제 이 부분을 고려해서 올바르게 고쳐보자.

### 게시판에 글 쓰는 과정과 트랜잭션_올바른 예제

```
1) 처리 시작
2) 사용자의 로그인 여부 확인
3) 사용자의 글쓰기 내용의 오류 여부 확인
4) 첨부로 업로드 된 파일 확인 및 저장
==> 데이터 베이스 커넥션 시작
==> 트랜잭션 시작
5) 사용자의 입력 내용을 DBMS에 저장
6) 첨부 파일 정보를 DBMS에 저장
<== 트랜잭션 종료(COMMIT)
7) 저장된 내용 또는 기타 정보를 DBMS에서 조회
8) 게시물 등록에 대한 알림 메일을 발송
==> 트랜잭션 시작
9) 알람 메일 발송 이력을 DBMS에 저장
<== 트랜잭션 종료(COMMIT)
<== 데이터베이스 커넥션 반납, 커넥션 종료
10) 처리 완료
```

여기서 중요한 것은, 프로그램의 코드가 데이터베이스 커넥션을 가지고 있는 범위와 트랜잭션이 활성화돼있는 프로그램의 범위를 최소화 해야 한다는 것이다.

특히, 네트워크와 관련된 작업이 있는 경우 반드시 트랜잭션에서 배제해야 한다는 사실을 잊지 말자.

이런 실수로 인해 DBMS 서버가 높은 부하 상태로 빠지거나 위험한 상태에 빠지는 경우가 빈번히 발생한다!!